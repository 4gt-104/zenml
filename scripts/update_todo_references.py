import json
import os
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import requests
from requests.auth import HTTPBasicAuth

PRIORITIES = {"LOW": 4, "MEDIUM": 3, "HIGH": 2}

JIRA_BASE_URL = os.environ["JIRA_BASE_URL"]
JIRA_USERNAME = os.environ["JIRA_USERNAME"]
JIRA_API_TOKEN = os.environ["JIRA_API_TOKEN"]

JIRA_BOARD_ID = os.environ["JIRA_BOARD_ID"]
JIRA_ISSUE_TYPE_ID = os.environ["JIRA_ISSUE_TYPE_ID"]
JIRA_DONE_STATUS_CATEGORY_ID = 3
JIRA_ISSUE_LABEL = "todo_comment"


class Todo:
    """Represents a TODO comment in code."""
    def __init__(
        self,
        filepath: str,
        description: str,
        priority: Optional[str] = None,
        issue_key: Optional[str] = None,
    ):
        self.filepath = filepath
        self.description = description
        self.priority = priority
        self.issue_key = issue_key


class JiraIssue:
    """Represents an issue from a JIRA board."""
    def __init__(self, key: str, done: bool):
        self.key = key
        self.done = done


def issue_payload_for_todo(todo: Todo) -> Dict[str, Any]:
    """Returns the http request data required to create a JIRA issue for the
    given Todo object."""
    title = (
        f"Autogenerated issue from TODO comment in file {todo.filepath}."
    )
    return {
        "fields": {
            "summary": title,
            "issuetype": {"id": f"{JIRA_ISSUE_TYPE_ID}"},
            "project": {"id": f"{JIRA_BOARD_ID}"},
            "priority": {"id": f"{PRIORITIES[todo.priority]}"},
            "labels": [JIRA_ISSUE_LABEL],
            "description": {
                "type": "doc",
                "version": 1,
                "content": [
                    {
                        "type": "paragraph",
                        "content": [{"text": todo.description, "type": "text"}],
                    }
                ],
            },
        },
    }


def create_jira_issues(todos: List[Todo]) -> None:
    """Creates JIRA issues for the given Todos and updates their issue keys."""
    url = f"{JIRA_BASE_URL}/rest/api/3/issue/bulk"
    auth = HTTPBasicAuth(JIRA_USERNAME, JIRA_API_TOKEN)
    headers = {"Accept": "application/json", "Content-Type": "application/json"}

    payload = json.dumps(
        {"issueUpdates": [issue_payload_for_todo(todo) for todo in todos]}
    )

    response = requests.request(
        "POST", url, data=payload, headers=headers, auth=auth
    )

    issues = json.loads(response.text)["issues"]
    for todo, issue in zip(todos, issues):
        todo.issue_key = issue["key"]


def get_all_jira_todo_issues() -> List[JiraIssue]:
    """Returns a list of all JIRA issues in the board specified by
    `JIRA_BOARD_ID` and the label specified in `JIRA_ISSUE_LABEL`."""
    url = f"{JIRA_BASE_URL}/rest/api/3/search"
    auth = HTTPBasicAuth(JIRA_USERNAME, JIRA_API_TOKEN)
    headers = {"Accept": "application/json", "Content-Type": "application/json"}

    query = {
        "jql": f'project = {JIRA_BOARD_ID} AND labels = "{JIRA_ISSUE_LABEL}"',
        "fields": "status",
        "maxResults": 500,
    }

    response = requests.request(
        "GET", url, params=query, headers=headers, auth=auth
    )

    issues = []
    for issue_dict in response.json()["issues"]:
        status_category = issue_dict["fields"]["status"]["statusCategory"]["id"]
        is_done = status_category == JIRA_DONE_STATUS_CATEGORY_ID
        issues.append(JiraIssue(key=issue_dict["key"], done=is_done))

    return issues


def remove_todos_for_closed_issues(
    file: Path, todos: List[Todo], issues: List[JiraIssue]
) -> None:
    """Removes Todos if their referenced issue was closed.

    Args:
        file: The file for which to remove the todos.
        todos: All todos with issue reference found in this file.
        issues: All jira issues referencing code todos.
    """
    open_issue_keys = {issue.key for issue in issues if not issue.done}
    todos_to_delete = [
        todo.issue_key
        for todo in todos
        if todo.issue_key not in open_issue_keys
    ]

    if todos_to_delete:
        file_content = file.read_text()

        regex = re.compile(
            r"^[ \t]*# TODO ?\[("
            + "|".join(todos_to_delete)
            + r")\] ?:(.*$\n(^[ \t]*# {2}.*$\n)*)",
            flags=re.MULTILINE
        )
        new_file_content = re.sub(
            regex,
            "",
            file_content,
        )

        file.write_text(new_file_content)
        print(f"Deleted {len(todos_to_delete)} todos in file '{file}'.")


def find_todos(file: Path) -> Tuple[List[Todo], List[Todo]]:
    """Finds referenced and unreferenced Todos in a file.

    Args:
        file: The file to search.

    Returns: A tuple (unreferenced_todos, referenced_todos) for todos
        without/with reference to jira issues.
    """
    file_content = file.read_text()

    matches = re.findall(
        r"^[ \t]*# TODO ?\[(LOW|MEDIUM|HIGH|[A-Z]*?-[0-9]*?)\] ?:"
        r"(.*$\n(^[ \t]*# {2}.*$\n)*)",
        file_content,
        flags=re.MULTILINE,
    )

    unreferenced_todos = []
    referenced_todos = []

    for priority_or_key, description, _ in matches:
        # remove whitespace and leading '#' from description
        lines = description.split("\n")
        lines = [line.strip().lstrip("#").strip() for line in lines]
        description = " ".join(lines)

        todo = Todo(filepath=str(file), description=description)
        if priority_or_key in PRIORITIES:
            todo.priority = priority_or_key
            unreferenced_todos.append(todo)
        else:
            todo.issue_key = priority_or_key
            referenced_todos.append(todo)

    print(f"Found {len(unreferenced_todos)} unreferenced and "
          f"{len(referenced_todos)} referenced todos in file '{file}'.")

    return unreferenced_todos, referenced_todos


def update_file_with_issue_keys(file: Path, todos: List[Todo]) -> None:
    """Replaces TODO priorities by the issue key that the TODO is referencing.

    Args:
        file: The file in which the todos will be replaced.
        todos: The todos to replace.
    """
    file_content = file.read_text()
    todo_iterator = iter(todos)

    def _replace(match):
        todo = next(todo_iterator)
        result = match.group(1) + f"{todo.issue_key}" + match.group(3)
        return result

    new_file_content = re.sub(
        r"(^[ \t]*# TODO ?\[)(LOW|MEDIUM|HIGH)(\] ?:"
        r".*$\n(^[ \t]*# {2}.*$\n)*)",
        _replace,
        file_content,
        flags=re.MULTILINE,
    )

    file.write_text(new_file_content)
    print(f"Added issue references for {len(todos)} todos in file '{file}'.")


def update_todo_references() -> None:
    """Updates TODO comment references.

    This method
    - creates JIRA issues for all TODO comments that don't reference
        an issue yet and
    - removes TODO comments that reference a JIRA issue that was closed
    """
    zenml_root = Path("src/zenml")
    # test_root = Path("tests")
    # python_files = itertools.chain(
    #     zenml_root.rglob("*.py"), test_root.rglob("*.py")
    # )
    python_files = zenml_root.rglob("*.py")
    jira_issues = get_all_jira_todo_issues()

    for file in python_files:
        unreferenced_todos, referenced_todos = find_todos(file)

        if referenced_todos:
            remove_todos_for_closed_issues(file, referenced_todos, jira_issues)

        if unreferenced_todos:
            create_jira_issues(unreferenced_todos)
            update_file_with_issue_keys(file, unreferenced_todos)


if __name__ == "__main__":
    update_todo_references()
