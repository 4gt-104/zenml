#  Copyright (c) ZenML GmbH 2023. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at:
#
#       https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
#  or implied. See the License for the specific language governing
#  permissions and limitations under the License.
"""Service connector CLI commands."""

from typing import Any, List, Optional
from uuid import UUID

import click

from zenml.cli import utils as cli_utils
from zenml.cli.cli import TagGroup, cli
from zenml.cli.utils import (
    list_options,
    print_page_info,
)
from zenml.client import Client
from zenml.console import console
from zenml.enums import CliCategories
from zenml.exceptions import AuthorizationException, IllegalOperationError
from zenml.models import (
    ServiceConnectorBaseModel,
    ServiceConnectorFilterModel,
    ServiceConnectorResourceListModel,
)


# Service connectors
@cli.group(
    cls=TagGroup,
    tag=CliCategories.IDENTITY_AND_SECURITY,
)
def service_connector() -> None:
    """Configure and manage service connectors."""


@service_connector.command(
    "register",
    context_settings={"ignore_unknown_options": True},
    help="""Configure, validate and register a ZenML service connector.
""",
)
@click.argument(
    "name",
    type=str,
    required=False,
)
@click.option(
    "--description",
    "description",
    help="Short description for the connector instance.",
    required=False,
    type=str,
)
@click.option(
    "--type",
    "-t",
    "connector_type",
    help="The service connector type.",
    required=False,
    type=str,
)
@click.option(
    "--resource-type",
    "-r",
    "resource_type",
    help="The type of resource to connect to.",
    required=False,
    type=str,
)
@click.option(
    "--resource-id",
    "-ri",
    "resource_id",
    help="The ID of the resource to connect to.",
    required=False,
    type=str,
)
@click.option(
    "--auth-method",
    "-a",
    "auth_method",
    help="The authentication method to use.",
    required=False,
    type=str,
)
@click.option(
    "--expiration-seconds",
    "expiration_seconds",
    help="The duration, in seconds, that the temporary credentials "
    "generated by this connector should remain valid.",
    required=False,
    type=int,
)
@click.option(
    "--label",
    "-l",
    "labels",
    help="Labels to be associated with the service connector. Takes the form "
    "-l key1=value1 and can be used multiple times.",
    multiple=True,
)
@click.option(
    "--share",
    "share",
    is_flag=True,
    default=False,
    help="Share this service connector with other users.",
    type=click.BOOL,
)
@click.option(
    "--no-verify",
    "no_verify",
    is_flag=True,
    default=False,
    help="Do not verify the service connector before registering.",
    type=click.BOOL,
)
@click.option(
    "--interactive",
    "-i",
    "interactive",
    is_flag=True,
    default=False,
    help="Register a new service connector interactively.",
    type=click.BOOL,
)
@click.option(
    "--auto-configure",
    "auto_configure",
    is_flag=True,
    default=False,
    help="Auto configure the service connector.",
    type=click.BOOL,
)
@click.argument("args", nargs=-1, type=click.UNPROCESSED)
def register_service_connector(
    name: Optional[str],
    args: List[str],
    description: Optional[str] = None,
    connector_type: Optional[str] = None,
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
    auth_method: Optional[str] = None,
    expiration_seconds: Optional[int] = None,
    share: bool = False,
    no_verify: bool = False,
    labels: Optional[List[str]] = None,
    interactive: bool = False,
    auto_configure: bool = False,
) -> None:
    """Registers a service connector.

    Args:
        name: The name to use for the service connector.
        args: Configuration arguments for the service connector.
        description: Short description for the service connector.
        type: The service connector type.
        resource_type: The type of resource to connect to.
        resource_id: The ID of the resource to connect to.
        auth_method: The authentication method to use.
        expiration_seconds: The duration, in seconds, that the temporary
            credentials generated by this connector should remain valid.
        share: Share the service connector with other users.
        no_verify: Do not verify the service connector before
            registering.
        labels: Labels to be associated with the service connector.
        interactive: Register a new service connector interactively.
        auto_configure: Auto configure the service connector.
    """
    from rich.markdown import Markdown

    client = Client()

    # Parse the given args
    name, parsed_args = cli_utils.parse_name_and_extra_arguments(
        list(args) + [name or ""],
        expand_args=True,
        name_mandatory=not interactive,
    )

    parsed_labels = cli_utils.get_parsed_labels(labels)

    if interactive:
        # Get the list of available service connector types
        connector_types = client.list_service_connector_types(
            connector_type=connector_type,
            resource_type=resource_type,
            auth_method=auth_method,
        )
        if not connector_types:
            cli_utils.error(
                "No service connectors found with the given parameters: "
                + f"type={connector_type} "
                if connector_type
                else "" + f"resource_type={resource_type} "
                if resource_type
                else "" + f"auth_method={auth_method} "
                if auth_method
                else "",
            )

        while True:
            # Ask for a name
            name = click.prompt(
                "Please enter a name for the service connector",
                type=str,
                default=name,
            )
            if not name:
                cli_utils.warning("The name cannot be empty")
                continue
            # Check if the name is taken
            try:
                client.get_service_connector(
                    name_id_or_prefix=name, allow_name_prefix_match=False
                )
            except KeyError:
                break
            else:
                cli_utils.warning(
                    f"A service connector with the name '{name}' already "
                    "exists. Please choose a different name."
                )

        # Ask for a description
        description = click.prompt(
            "Please enter a description for the service connector",
            type=str,
            default="",
        )

        available_types = {c.type: c for c in connector_types}
        if len(available_types) == 1:
            # Default to the first connector type if not supplied and if
            # only one type is available
            connector_type = connector_type or list(available_types.keys())[0]

        message = "# Available service connector types\n"
        # Print the name, type and description of all available service
        # connectors
        for spec in connector_types:
            message += f"## {spec.name} ({spec.type})\n"
            message += f"{spec.description}\n"

        console.print(Markdown(f"{message}---"), justify="left", width=80)

        # Ask the user to select a service connector type
        connector_type = click.prompt(
            "Please select a service connector type",
            type=click.Choice(list(available_types.keys())),
            default=connector_type,
        )

        assert connector_type is not None
        connector_type_spec = available_types[connector_type]

        # Ask the user whether to use auto-configuration, if the connector
        # implementation is locally available
        if connector_type_spec.local:
            auto_configure = click.confirm(
                "Would you like to attempt auto-configuration to extract the "
                "authentication configuration from your local environment ?",
                default=False,
            )
        else:
            auto_configure = False

        auth_method: Optional[str] = None
        connector_resources: Optional[ServiceConnectorResourceListModel] = None
        connector_model: Optional[ServiceConnectorBaseModel] = None
        if auto_configure:
            # Try to auto-configure the service connector
            try:
                with console.status("Auto-configuring service connector...\n"):

                    (
                        connector_model,
                        connector_resources,
                    ) = client.create_service_connector(
                        name=name,
                        description=description or "",
                        type=connector_type,
                        is_shared=share,
                        auto_configure=True,
                        verify=True,
                        register=False,
                    )

                assert connector_model is not None
                assert connector_resources is not None
            except (
                KeyError,
                ValueError,
                IllegalOperationError,
                NotImplementedError,
                AuthorizationException,
            ) as e:
                cli_utils.warning(
                    f"Auto-configuration was not successful: {e} "
                )
                # Ask the user whether to continue with manual configuration
                manual = click.confirm(
                    "Would you like to continue with manual configuration ?",
                    default=True,
                )
                if not manual:
                    return
            else:
                auth_method = connector_model.auth_method
                cli_utils.declare(
                    "Service connector auto-configured successfully with the "
                    "following configuration:"
                )
                cli_utils.print_service_connector_configuration(
                    connector_model,
                    active_status=False,
                    show_secrets=False,
                )
                # Ask the user whether to continue with the auto configuration
                choice = click.prompt(
                    "Would you like to continue with the auto-discovered "
                    "configuration or switch to manual ?",
                    type=click.Choice(["auto", "manual"]),
                    default="auto",
                )
                if choice == "manual":
                    # Reset the auto-configured connector
                    connector_model = None
                    connector_resources = None

        if connector_model is not None and connector_resources is not None:
            assert auth_method is not None
            auth_method_spec = connector_type_spec.auth_method_map[auth_method]
        else:
            auth_methods = list(connector_type_spec.auth_method_map.keys())

            message = "# Available authentication methods\n"
            # Print the name, identifier and description of all available auth
            # methods
            for a in auth_methods:
                auth_method_spec = connector_type_spec.auth_method_map[a]
                message += f"## {auth_method_spec.name} ({a})\n"
                message += f"{auth_method_spec.description}\n"

            console.print(Markdown(f"{message}---"), justify="left", width=80)

            if len(auth_methods) == 1:
                # Default to the first auth method if only one method is available
                confirm = click.confirm(
                    "Only one authentication method is available for this "
                    f"connector ({auth_methods[0]}). Would you like to use it?",
                    default=True,
                )
                if not confirm:
                    return

                auth_method = auth_methods[0]
            else:
                # Ask the user to select an authentication method
                auth_method = click.prompt(
                    "Please select an authentication method",
                    type=click.Choice(auth_methods),
                    default=auth_method,
                )

            assert auth_method is not None
            auth_method_spec = connector_type_spec.auth_method_map[auth_method]

            cli_utils.declare(
                f"Please enter the configuration for the {auth_method_spec.name} "
                "authentication method."
            )

            config_schema = auth_method_spec.config_schema or {}
            config_dict = {}
            for attr_name, attr_schema in config_schema.get(
                "properties", {}
            ).items():
                title = attr_schema.get("title", attr_name)
                title = f"[{attr_name}] {title}"
                required = attr_name in config_schema.get("required", [])
                hidden = attr_schema.get("format", "") == "password"
                subtitles: List[str] = []
                if hidden:
                    subtitles.append("hidden")
                if required:
                    subtitles.append("required")
                else:
                    subtitles.append("optional")
                if subtitles:
                    title += f" {{{', '.join(subtitles)}}}"

                while True:
                    # Ask the user to enter a value for the attribute
                    default = parsed_args.get(
                        attr_name, "" if not required else None
                    )
                    value = click.prompt(
                        title,
                        type=str,
                        hide_input=hidden,
                        default=default,
                        show_default=default not in (None, ""),
                    )
                    if not value:
                        if required:
                            cli_utils.warning(
                                f"The attribute '{title}' is mandatory. "
                                "Please enter a non-empty value."
                            )
                            continue
                        else:
                            value = None
                            break
                    else:
                        config_dict[attr_name] = value
                        break

            if auth_method_spec.supports_temporary_credentials():
                while True:
                    if auth_method_spec.min_expiration_seconds is not None:
                        min = auth_method_spec.min_expiration_seconds
                    else:
                        min = 0
                    if auth_method_spec.max_expiration_seconds is not None:
                        max = auth_method_spec.max_expiration_seconds
                        max_str = str(max)
                    else:
                        max = -1
                        max_str = "unlimited"

                    expiration_seconds = click.prompt(
                        "The authentication method involves generating "
                        "temporary credentials. Please enter the time that "
                        "the credentials should be valid for, in seconds "
                        f"({min}-{max_str})",
                        type=int,
                        default=auth_method_spec.default_expiration_seconds,
                    )

                    assert expiration_seconds is not None
                    if expiration_seconds < min:
                        cli_utils.warning(
                            f"The expiration time must be at least "
                            f"{min} seconds. Please enter a larger value."
                        )
                        continue
                    if max > 0 and expiration_seconds > max:
                        cli_utils.warning(
                            f"The expiration time must not exceed "
                            f"{max} seconds. Please enter a smaller value."
                        )
                        continue
                    break

            try:
                with console.status(
                    "Validating service connector configuration...\n"
                ):

                    (
                        connector_model,
                        connector_resources,
                    ) = client.create_service_connector(
                        name=name,
                        description=description or "",
                        type=connector_type,
                        auth_method=auth_method,
                        configuration=config_dict,
                        expiration_seconds=expiration_seconds,
                        is_shared=share,
                        auto_configure=False,
                        verify=True,
                        register=False,
                    )
                assert connector_model is not None
                assert connector_resources is not None
            except (
                KeyError,
                ValueError,
                IllegalOperationError,
                NotImplementedError,
                AuthorizationException,
            ) as e:
                cli_utils.error(f"Failed to configure service connector: {e}")

        available_resource_types = [
            t.resource_type
            for t in connector_type_spec.resource_types
            if auth_method in t.auth_methods
        ]

        # available_resources = []
        # for typed_resource in connector_resources.resources:
        #     available_resources.append(
        #         (
        #             typed_resource.resource_type,
        #             typed_resource.resource_type_name,
        #             None,
        #         )
        #     )
        #     if not typed_resource.multi_instance:
        #         continue
        #     if typed_resource.instance_discovery:
        #         for resource_id in typed_resource.resource_ids:
        #             available_resources.append(
        #                 (
        #                     typed_resource.resource_type,
        #                     typed_resource.resource_type_name,
        #                     resource_id,
        #                 )
        #             )
        #         continue
        #     available_resources.append(
        #         (
        #             typed_resource.resource_type,
        #             typed_resource.resource_type_name,
        #             "<enter resource ID manually>",
        #         )
        #     )

        message = "# Available resource types\n"
        # Print the name, resource type identifiers and description of all
        # available resource types
        for r in connector_type_spec.resource_types:
            message += f"## {r.name} ({r.resource_type})\n"
            message += f"{r.description}\n"

        console.print(Markdown(f"{message}---"), justify="left", width=80)

        resource_type: Optional[str] = None
        if len(available_resource_types) == 1:
            # Default to the first resource type if only one type is available
            confirm = click.confirm(
                "Only one resource type is available for this connector"
                f" ({available_resource_types[0]}). Would you like to use it?",
                default=True,
            )
            if not confirm:
                return

            resource_type = available_resource_types[0]
        else:
            # Ask the user to select a resource type
            while True:
                resource_type = click.prompt(
                    "Please select a resource type or leave it empty to create "
                    "a connector that can be used to access any of the "
                    "supported resource types "
                    f"({', '.join(available_resource_types)}).",
                    type=str,
                    default="",
                )
                if (
                    resource_type
                    and resource_type not in available_resource_types
                ):
                    cli_utils.warning(
                        f"The entered resource type '{resource_type}' is not "
                        "one of the listed values. Please try again."
                    )
                    continue
                break

            if resource_type == "":
                resource_type = None

        if resource_type:
            resource_type_spec = connector_type_spec.resource_type_map[
                resource_type
            ]

            if resource_type_spec.multi_instance:

                resource_ids: List[str] = []
                if resource_type_spec.instance_discovery:
                    resource_ids = [
                        r.resource_ids
                        for r in connector_resources.resources
                        if r.resource_type == resource_type
                    ][0]

                if resource_type_spec.instance_discovery and not resource_ids:
                    cli_utils.error(
                        "The connector instance does not have access to any "
                        f"{resource_type_spec.name} instances. This means "
                        "that the connector credentials are not valid or that "
                        "the permissions are insufficient. Please "
                        "check your configuration and try again."
                    )

                if resource_ids:
                    resource_ids_list = "\n - " + "\n - ".join(resource_ids)
                    prompt = (
                        f"The following {resource_type_spec.name} instances "
                        "are reachable through this connector:"
                        f"{resource_ids_list}\n"
                        "Please select one or leave it empty to create a "
                        "connector that can be used to access any of them"
                    )
                    while True:
                        # Ask the user to enter an optional resource ID
                        resource_id = click.prompt(
                            prompt,
                            default="",
                            type=str,
                        )
                        if (
                            not resource_ids
                            or not resource_id
                            or resource_id in resource_ids
                        ):
                            break

                        cli_utils.warning(
                            f"The selected '{resource_id}' value is not one of "
                            "the listed values. Please try again."
                        )
                else:
                    prompt = (
                        "The connector configuration can be used to access "
                        f"multiple {resource_type_spec.name} instances. If you "
                        "would like to limit the scope of the connector to one "
                        "instance, please enter the ID of a particular "
                        f"{resource_type_spec.name} instance. Or leave it "
                        "empty to create a multi-instance connector that can "
                        "be used to access any {resource_type_spec.name}"
                    )
                    resource_id = click.prompt(
                        prompt,
                        default="",
                        type=str,
                    )

                if resource_id == "":
                    resource_id = None
            else:
                resource_id = None
        else:
            resource_id = None

        # Prepare the rest of the variables to fall through to the
        # non-interactive configuration case
        parsed_args = connector_model.configuration
        parsed_args.update(connector_model.secrets)
        auto_configure = False
        no_verify = False
        expiration_seconds = connector_model.expiration_seconds

    if not connector_type:
        cli_utils.error(
            "The connector type must be specified when using non-interactive "
            "configuration."
        )

    if not auth_method and not auto_configure:
        cli_utils.error(
            "The authentication method must be specified when using "
            "non-interactive configuration and not using auto-configuration."
        )

    with console.status(f"Registering service connector '{name}'...\n"):
        try:
            # Create a new service connector
            assert name is not None
            client.create_service_connector(
                name=name,
                type=connector_type,
                auth_method=auth_method,
                resource_type=resource_type,
                configuration=parsed_args,
                resource_id=resource_id,
                description=description or "",
                expiration_seconds=expiration_seconds,
                is_shared=share,
                labels=parsed_labels,
                verify=not no_verify,
                auto_configure=auto_configure,
                register=True,
            )
        except (
            KeyError,
            ValueError,
            IllegalOperationError,
            NotImplementedError,
            AuthorizationException,
        ) as e:
            cli_utils.error(f"Failed to register service connector: {e}")

        cli_utils.declare(
            f"Successfully registered service connector `{name}`."
        )


@service_connector.command(
    "list",
    help="""List available service connectors.
""",
)
@list_options(ServiceConnectorFilterModel)
def list_service_connectors(**kwargs: Any) -> None:
    """List all service connectors.

    Args:
        kwargs: Keyword arguments to filter the components.
    """
    client = Client()

    connectors = client.list_service_connectors(**kwargs)
    if not connectors:
        cli_utils.declare("No service connectors found for the given filters.")
        return

    cli_utils.print_service_connectors_table(
        client=client,
        connectors=connectors.items,
    )
    print_page_info(connectors)


@service_connector.command(
    "describe",
    help="""Show detailed information about a service connector.
""",
)
@click.argument(
    "name_id_or_prefix",
    type=str,
    required=True,
)
@click.option(
    "--show-secrets",
    "-x",
    "show_secrets",
    is_flag=True,
    default=False,
    help="Show security sensitive configuration attributes in the terminal.",
    type=click.BOOL,
)
@click.option(
    "--resource-type",
    "-r",
    "resource_type",
    help="Use a resource type to fetch and describe a client service connector "
    "instead of the base connector.",
    required=False,
    type=str,
)
@click.option(
    "--resource-id",
    "-ri",
    "resource_id",
    help="Use a resource ID to fetch and describe a client service connector "
    "instead of the base connector.",
    required=False,
    type=str,
)
def describe_service_connector(
    name_id_or_prefix: str,
    show_secrets: bool = False,
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
) -> None:
    """Prints details about a service connector.

    Args:
        name_id_or_prefix: Name or id of the service connector to describe.
        show_secrets: Whether to show security sensitive configuration
            attributes in the terminal.
        resource_type: Use a resource type to fetch and describe a client
            service connector instead of the base connector.
        resource_id: Use a resource ID to fetch and describe a client service
            connector instead of the base connector.
    """
    client = Client()

    if resource_type or resource_id:
        try:
            client_connector = client.get_service_connector_client(
                name_id_or_prefix=name_id_or_prefix,
                resource_type=resource_type,
                resource_id=resource_id,
            )
        except (
            KeyError,
            ValueError,
            IllegalOperationError,
            NotImplementedError,
            AuthorizationException,
        ) as e:
            resource_type = resource_type or "<unspecified>"
            resource_id = resource_id or "<unspecified>"
            cli_utils.error(
                f"Failed fetching a client service connector for connector "
                f"'{name_id_or_prefix}', resource type '{resource_type}' and "
                f"resource ID {resource_id}: {e}"
            )

        connector = client_connector.to_response_model(
            workspace=client.active_workspace,
            user=client.active_user,
        )
    else:
        try:
            connector = client.get_service_connector(
                name_id_or_prefix=name_id_or_prefix,
            )
        except KeyError as err:
            cli_utils.error(str(err))

        if connector.secret_id:
            try:
                secret = client.get_secret(
                    name_id_or_prefix=connector.secret_id,
                    allow_partial_id_match=False,
                    allow_partial_name_match=False,
                )
            except KeyError as err:
                cli_utils.warning(
                    "Unable to retrieve secret values associated with "
                    f"service connector '{connector.name}': {err}"
                )
            else:
                # Add secret values to connector configuration
                connector.secrets.update(secret.values)

    with console.status(f"Describing connector '{connector.name}'..."):
        active_stack = client.active_stack_model
        active_connector_ids: List[UUID] = []
        for components in active_stack.components.values():
            active_connector_ids.extend(
                [
                    component.connector.id
                    for component in components
                    if component.connector
                ]
            )

        cli_utils.print_service_connector_configuration(
            connector=connector,
            active_status=connector.id in active_connector_ids,
            show_secrets=show_secrets,
        )


# def generate_stack_component_update_command(
#     component_type: StackComponentType,
# ) -> Callable[[str, List[str]], None]:
#     """Generates an `update` command for the specific stack component type.

#     Args:
#         component_type: Type of the component to generate the command for.

#     Returns:
#         A function that can be used as a `click` command.
#     """
#     display_name = _component_display_name(component_type)

#     @click.argument(
#         "name_id_or_prefix",
#         type=str,
#         required=False,
#     )
#     @click.argument("args", nargs=-1, type=click.UNPROCESSED)
#     def update_stack_component_command(
#         name_id_or_prefix: Optional[str], args: List[str]
#     ) -> None:
#         """Updates a stack component.

#         Args:
#             name_id_or_prefix: The name or id of the stack component to update.
#             args: Additional arguments to pass to the update command.
#         """
#         if component_type == StackComponentType.SECRETS_MANAGER:
#             warn_deprecated_secrets_manager()

#         client = Client()

#         # Parse the given args
#         args = list(args)
#         if name_id_or_prefix:
#             args.append(name_id_or_prefix)

#         name_or_id, parsed_args = cli_utils.parse_name_and_extra_arguments(
#             args,
#             expand_args=True,
#             name_mandatory=False,
#         )

#         with console.status(f"Updating {display_name}...\n"):
#             try:
#                 updated_component = client.update_stack_component(
#                     name_id_or_prefix=name_or_id,
#                     component_type=component_type,
#                     configuration=parsed_args,
#                 )
#             except KeyError as err:
#                 cli_utils.error(str(err))

#             cli_utils.declare(
#                 f"Successfully updated {display_name} "
#                 f"`{updated_component.name}`."
#             )

#     return update_stack_component_command


@service_connector.command(
    "share",
    help="""Share a service connector with other users.
""",
)
@click.argument(
    "name_id_or_prefix",
    type=str,
    required=False,
)
def share_service_connector_command(
    name_id_or_prefix: str,
) -> None:
    """Shares a service connector.

    Args:
        name_id_or_prefix: The name or id of the service connector to share.
    """
    client = Client()

    with console.status(
        f"Updating service connector '{name_id_or_prefix}'...\n"
    ):
        try:
            client.update_service_connector(
                name_id_or_prefix=name_id_or_prefix,
                is_shared=True,
            )
        except (KeyError, IllegalOperationError) as err:
            cli_utils.error(str(err))

        cli_utils.declare(
            "Successfully shared service connector " f"`{name_id_or_prefix}`."
        )


# def generate_stack_component_remove_attribute_command(
#     component_type: StackComponentType,
# ) -> Callable[[str, List[str]], None]:
#     """Generates `remove_attribute` command for a specific stack component type.

#     Args:
#         component_type: Type of the component to generate the command for.

#     Returns:
#         A function that can be used as a `click` command.
#     """
#     display_name = _component_display_name(component_type)

#     @click.argument(
#         "name_id_or_prefix",
#         type=str,
#         required=True,
#     )
#     @click.argument("args", nargs=-1, type=click.UNPROCESSED)
#     def remove_attribute_stack_component_command(
#         name_id_or_prefix: str, args: List[str]
#     ) -> None:
#         """Removes one or more attributes from a stack component.

#         Args:
#             name_id_or_prefix: The name of the stack component to remove the
#                 attribute from.
#             args: Additional arguments to pass to the remove_attribute command.
#         """
#         if component_type == StackComponentType.SECRETS_MANAGER:
#             warn_deprecated_secrets_manager()

#         client = Client()

#         with console.status(
#             f"Updating {display_name} '{name_id_or_prefix}'...\n"
#         ):
#             try:
#                 client.update_stack_component(
#                     name_id_or_prefix=name_id_or_prefix,
#                     component_type=component_type,
#                     configuration={k: None for k in args},
#                 )
#             except (KeyError, IllegalOperationError) as err:
#                 cli_utils.error(str(err))

#             cli_utils.declare(
#                 f"Successfully updated {display_name} `{name_id_or_prefix}`."
#             )

#     return remove_attribute_stack_component_command


# def generate_stack_component_rename_command(
#     component_type: StackComponentType,
# ) -> Callable[[str, str], None]:
#     """Generates a `rename` command for the specific stack component type.

#     Args:
#         component_type: Type of the component to generate the command for.

#     Returns:
#         A function that can be used as a `click` command.
#     """
#     display_name = _component_display_name(component_type)

#     @click.argument(
#         "name_id_or_prefix",
#         type=str,
#         required=True,
#     )
#     @click.argument(
#         "new_name",
#         type=str,
#         required=True,
#     )
#     def rename_stack_component_command(
#         name_id_or_prefix: str, new_name: str
#     ) -> None:
#         """Rename a stack component.

#         Args:
#             name_id_or_prefix: The name of the stack component to rename.
#             new_name: The new name of the stack component.
#         """
#         if component_type == StackComponentType.SECRETS_MANAGER:
#             warn_deprecated_secrets_manager()

#         client = Client()

#         with console.status(
#             f"Renaming {display_name} '{name_id_or_prefix}'...\n"
#         ):
#             try:
#                 client.update_stack_component(
#                     name_id_or_prefix=name_id_or_prefix,
#                     component_type=component_type,
#                     name=new_name,
#                 )
#             except (KeyError, IllegalOperationError) as err:
#                 cli_utils.error(str(err))

#             cli_utils.declare(
#                 f"Successfully renamed {display_name} `{name_id_or_prefix}` to"
#                 f" `{new_name}`."
#             )

#     return rename_stack_component_command


@service_connector.command(
    "delete",
    help="""Delete a service connector.
""",
)
@click.argument("name_id_or_prefix", type=str)
def delete_service_connector(name_id_or_prefix: str) -> None:
    """Deletes a service connector.

    Args:
        name_id_or_prefix: The name of the service connector to delete.
    """
    client = Client()

    with console.status(
        f"Deleting service connector '{name_id_or_prefix}'...\n"
    ):
        try:
            client.delete_service_connector(
                name_id_or_prefix=name_id_or_prefix,
            )
        except (KeyError, IllegalOperationError) as err:
            cli_utils.error(str(err))
        cli_utils.declare(f"Deleted service connector: {name_id_or_prefix}")


# def generate_stack_component_copy_command(
#     component_type: StackComponentType,
# ) -> Callable[[str, str], None]:
#     """Generates a `copy` command for the specific stack component type.

#     Args:
#         component_type: Type of the component to generate the command for.

#     Returns:
#         A function that can be used as a `click` command.
#     """
#     display_name = _component_display_name(component_type)

#     @click.argument(
#         "source_component_name_id_or_prefix", type=str, required=True
#     )
#     @click.argument("target_component", type=str, required=True)
#     @track(AnalyticsEvent.COPIED_STACK_COMPONENT)
#     def copy_stack_component_command(
#         source_component_name_id_or_prefix: str,
#         target_component: str,
#     ) -> None:
#         """Copies a stack component.

#         Args:
#             source_component_name_id_or_prefix: Name or id prefix of the
#                                          component to copy.
#             target_component: Name of the copied component.
#         """
#         if component_type == StackComponentType.SECRETS_MANAGER:
#             warn_deprecated_secrets_manager()

#         client = Client()

#         with console.status(
#             f"Copying {display_name} "
#             f"`{source_component_name_id_or_prefix}`..\n"
#         ):
#             try:
#                 component_to_copy = client.get_stack_component(
#                     name_id_or_prefix=source_component_name_id_or_prefix,
#                     component_type=component_type,
#                 )
#             except KeyError as err:
#                 cli_utils.error(str(err))

#             client.create_stack_component(
#                 name=target_component,
#                 flavor=component_to_copy.flavor,
#                 component_type=component_to_copy.type,
#                 configuration=component_to_copy.configuration,
#                 is_shared=component_to_copy.is_shared,
#             )

#     return copy_stack_component_command


@service_connector.command(
    "verify",
    help="""Verifies if a service connector has access to one or more resources.
""",
)
@click.option(
    "--resource-type",
    "-r",
    "resource_type",
    help="The type of the resource for which to verify access.",
    required=False,
    type=str,
)
@click.option(
    "--resource-id",
    "-ri",
    "resource_id",
    help="The ID of the resource for which to verify access.",
    required=False,
    type=str,
)
@click.argument("name_id_or_prefix", type=str, required=True)
def verify_service_connector(
    name_id_or_prefix: str,
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
) -> None:
    """Verifies if a service connector has access to one or more resources.

    Args:
        name_id_or_prefix: The name or id of the service connector to verify.
        resource_type: The type of resource for which to verify access.
        resource_id: The ID of the resource for which to verify access.
    """
    client = Client()

    with console.status(
        f"Verifying service connector '{name_id_or_prefix}'...\n"
    ):
        try:
            resources = client.verify_service_connector(
                name_id_or_prefix=name_id_or_prefix,
                resource_type=resource_type,
                resource_id=resource_id,
            )
        except (
            KeyError,
            ValueError,
            IllegalOperationError,
            NotImplementedError,
            AuthorizationException,
        ) as e:
            cli_utils.error(
                f"Service connector '{name_id_or_prefix}' verification failed: "
                f"{e}"
            )

        cli_utils.print_service_connector_resource_table(
            resources=[resources],
        )


@service_connector.command(
    "login",
    help="""Configure the local client/SDK with credentials extracted from
the service connector.
""",
)
@click.option(
    "--resource-type",
    "-r",
    "resource_type",
    help="The type of resource to connect to.",
    required=False,
    type=str,
)
@click.option(
    "--resource-id",
    "-ri",
    "resource_id",
    help="Explicit resource ID to connect to.",
    required=False,
    type=str,
)
@click.argument("name_id_or_prefix", type=str, required=True)
def login_service_connector(
    name_id_or_prefix: str,
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
) -> None:
    """Authenticate the local client/SDK with connector credentials.

    Args:
        name_id_or_prefix: The name or id of the service connector to use.
        resource_type: The type of resource to connect to.
        resource_id: Explicit resource ID to connect to.
    """
    client = Client()

    with console.status(
        "Attempting to configure local client using service connector "
        f"'{name_id_or_prefix}'...\n"
    ):
        try:
            connector = client.login_service_connector(
                name_id_or_prefix=name_id_or_prefix,
                resource_type=resource_type,
                resource_id=resource_id,
            )
        except (
            KeyError,
            ValueError,
            IllegalOperationError,
            NotImplementedError,
            AuthorizationException,
        ) as e:
            cli_utils.error(
                f"Service connector '{name_id_or_prefix}' could not configure "
                f"the local client/SDK: {e}"
            )

        spec = connector.get_type()
        resource_type = resource_type or connector.resource_type
        assert resource_type is not None
        resource_name = spec.resource_type_map[resource_type].name
        cli_utils.declare(
            f"The '{name_id_or_prefix}' {spec.name} connector was used to "
            f"successfully configure the local {resource_name} client/SDK."
        )


@service_connector.command(
    "list-resources",
    help="""List all resources that 
""",
)
@click.option(
    "--connector-type",
    "-c",
    "connector_type",
    help="The type of service connector to filter by.",
    required=False,
    type=str,
)
@click.option(
    "--resource-type",
    "-r",
    "resource_type",
    help="The type of resource to filter by.",
    required=False,
    type=str,
)
def list_service_connector_resources(
    connector_type: Optional[str] = None,
    resource_type: Optional[str] = None,
) -> None:
    """List resources that can be accessed by service connectors.

    Args:
        connector_type: The type of service connector to filter by.
        resource_type: The type of resource to filter by.
    """
    client = Client()

    with console.status("Fetching service connector resources...\n"):
        try:
            resource_list = client.list_service_connector_resources(
                connector_type=connector_type,
                resource_type=resource_type,
            )
        except (
            KeyError,
            ValueError,
            IllegalOperationError,
            NotImplementedError,
            AuthorizationException,
        ) as e:
            cli_utils.error(
                f"Could not fetch service connector resources: {e}"
            )

        cli_utils.print_service_connector_resource_table(
            resources=resource_list,
        )


# def generate_stack_component_explain_command(
#     component_type: StackComponentType,
# ) -> Callable[[], None]:
#     """Generates an `explain` command for the specific stack component type.

#     Args:
#         component_type: Type of the component to generate the command for.

#     Returns:
#         A function that can be used as a `click` command.
#     """

#     def explain_stack_components_command() -> None:
#         """Explains the concept of the stack component."""
#         if component_type == StackComponentType.SECRETS_MANAGER:
#             warn_deprecated_secrets_manager()

#         component_module = import_module(f"zenml.{component_type.plural}")

#         if component_module.__doc__ is not None:
#             md = Markdown(component_module.__doc__)
#             console.print(md)
#         else:
#             console.print(
#                 "The explain subcommand is yet not available for "
#                 "this stack component. For more information, you can "
#                 "visit our docs page: https://docs.zenml.io/ and "
#                 "stay tuned for future releases."
#             )

#     return explain_stack_components_command


@service_connector.command(
    "list-types",
    help="""List available service connector types.
""",
)
@click.option(
    "--type",
    "-t",
    "type",
    help="Filter by service connector type.",
    required=False,
    type=str,
)
@click.option(
    "--resource-type",
    "-r",
    "resource_type",
    help="Filter by the type of resource to connect to.",
    required=False,
    type=str,
)
@click.option(
    "--auth-method",
    "-a",
    "auth_method",
    help="Filter by the supported authentication method.",
    required=False,
    type=str,
)
@click.option(
    "--detailed",
    "-d",
    "detailed",
    help="Show detailed information about the service connectors.",
    required=False,
    is_flag=True,
)
def list_service_connector_types(
    type: Optional[str] = None,
    resource_type: Optional[str] = None,
    auth_method: Optional[str] = None,
    detailed: bool = False,
) -> None:
    """List service connector types.

    Args:
        type: Filter by service connector type.
        resource_type: Filter by the type of resource to connect to.
        auth_method: Filter by the supported authentication method.
        detailed: Show detailed information about the service connectors.
    """
    client = Client()

    service_connector_types = client.list_service_connector_types(
        connector_type=type,
        resource_type=resource_type,
        auth_method=auth_method,
    )

    if not service_connector_types:
        cli_utils.error("No service connectors found matching the criteria.")

    if detailed:
        for connector_type in service_connector_types:
            cli_utils.print_service_connector_type(connector_type)
    else:
        cli_utils.print_service_connector_types_table(
            connector_types=service_connector_types
        )


@service_connector.command(
    "get-type",
    help="""List available service connector types.
""",
)
@click.argument(
    "type",
    type=str,
    required=True,
)
def describe_service_connector_type(type: str) -> None:
    """Describes a service connector type.

    Args:
        type: The connector type to describe.
    """
    client = Client()

    try:
        connector_type = client.get_service_connector_type(type)
    except KeyError:
        cli_utils.error(f"Service connector type '{type}' not found.")

    cli_utils.print_service_connector_type(connector_type)
